# 软件工程

---

- [1. 概述](#1-概述)
    - [1.1. 软件的概念](#11-软件的概念)
    - [1.2. 软件发展历史](#12-软件发展历史)
        - [1.2.1. 软件产品分类](#121-软件产品分类)
    - [1.3. 软件开发一般过程](#13-软件开发一般过程)
    - [1.4. 如何理解软件工程](#14-如何理解软件工程)
        - [1.4.1. “工程”的基本内涵](#141-工程的基本内涵)
    - [1.5. 软件工程的根本特性](#15-软件工程的根本特性)
    - [1.6. 基本关注点](#16-基本关注点)
    - [1.7. 内容层次](#17-内容层次)
    - [1.8. 根本性困难](#18-根本性困难)
    - [1.9. 系统观与演化观](#19-系统观与演化观)
        - [1.9.1. 系统观](#191-系统观)
        - [1.9.2. 演化观](#192-演化观)
    - [1.10. 软件工程知识体系](#110-软件工程知识体系)
- [2. 软件过程](#2-软件过程)
    - [2.1. 软件过程含义](#21-软件过程含义)
        - [2.1.1. 三层含义](#211-三层含义)
    - [2.2. 软件过程发展历史](#22-软件过程发展历史)
    - [2.3. 软件过程模型（软件开发模型）](#23-软件过程模型软件开发模型)
    - [2.4. 经典软件过程模型](#24-经典软件过程模型)
        - [2.4.1. 瀑布模型](#241-瀑布模型)
        - [2.4.2. 增量模型](#242-增量模型)
        - [2.4.3. 演化模型](#243-演化模型)
        - [2.4.4. 统一过程模型](#244-统一过程模型)
    - [2.5. 软件过程改进](#25-软件过程改进)
    - [2.6. 敏捷过程](#26-敏捷过程)
        - [2.6.1. 敏捷过程的特点](#261-敏捷过程的特点)
    - [2.7. 精益思想](#27-精益思想)
        - [2.7.1. 改进原则](#271-改进原则)
    - [2.8. 敏捷思想与精益思想比较](#28-敏捷思想与精益思想比较)
    - [2.9. 例子](#29-例子)
    - [2.10. 开发运维一体化](#210-开发运维一体化)
        - [2.10.1. 技术价值流与技术实践](#2101-技术价值流与技术实践)
        - [2.10.2. 持续集成（CI）](#2102-持续集成ci)
        - [2.10.3. 持续交付](#2103-持续交付)
        - [2.10.4. 持续部署](#2104-持续部署)
- [3. 版本与开发任务管理](#3-版本与开发任务管理)
    - [3.1. 软件配置管理](#31-软件配置管理)
        - [3.1.1. 主要内容](#311-主要内容)
    - [3.2. 软件项目的持续规划、开发和发布](#32-软件项目的持续规划开发和发布)
    - [3.3. 版本](#33-版本)
        - [3.3.1. 版本发布计划](#331-版本发布计划)
        - [3.3.2. 版本管理](#332-版本管理)
        - [3.3.3. 产品版本号命名](#333-产品版本号命名)
        - [3.3.4. 场景示例](#334-场景示例)
    - [3.4. 版本控制系统](#34-版本控制系统)
        - [3.4.1. 集中式版本控制系统](#341-集中式版本控制系统)
        - [3.4.2. 分布式版本控制系统](#342-分布式版本控制系统)
        - [3.4.3. Git工作流成](#343-git工作流成)
            - [3.4.3.1. Commit](#3431-commit)
            - [3.4.3.2. 代码分支管理](#3432-代码分支管理)
            - [3.4.3.3. 基线管理](#3433-基线管理)
    - [3.5. 特性开发任务](#35-特性开发任务)
        - [3.5.1. 描述](#351-描述)
        - [3.5.2. 管理流程](#352-管理流程)
    - [3.6. 变更管理](#36-变更管理)
        - [3.6.1. 流程](#361-流程)
    - [3.7. 缺陷修复过程管理](#37-缺陷修复过程管理)
        - [3.7.1. 缺陷描述](#371-缺陷描述)
        - [3.7.2. 缺陷追踪系统主要功能](#372-缺陷追踪系统主要功能)
        - [3.7.3. 缺陷修复处理流程](#373-缺陷修复处理流程)
    - [3.8. 基于追踪与回溯的工作量与质量分析](#38-基于追踪与回溯的工作量与质量分析)
        - [3.8.1. 基于追踪的分析](#381-基于追踪的分析)
        - [3.8.2. 基于回溯的分析](#382-基于回溯的分析)
        - [3.8.3. 例子](#383-例子)
- [4. 高质量编码](#4-高质量编码)
    - [4.1. 代码质量](#41-代码质量)
    - [4.2. 代码质量要求](#42-代码质量要求)
        - [4.2.1. 可理解性、可维护性](#421-可理解性可维护性)
        - [4.2.2. 可靠性、信息安全性](#422-可靠性信息安全性)
        - [4.2.3. 高效性](#423-高效性)
        - [4.2.4. 可移植性](#424-可移植性)
    - [4.3. 代码风格](#43-代码风格)
        - [4.3.1. 标识符命名](#431-标识符命名)
    - [4.4. 代码注释](#44-代码注释)
        - [4.4.1. 基本原则](#441-基本原则)
        - [4.4.2. 常见有效类型](#442-常见有效类型)
    - [4.5. 高质量编码对代码逻辑的要求](#45-高质量编码对代码逻辑的要求)
        - [4.5.1. 基本要求](#451-基本要求)
        - [4.5.2. 控制变量作用域](#452-控制变量作用域)
        - [4.5.3. 正面实践](#453-正面实践)
    - [4.6. 重复代码问题](#46-重复代码问题)
        - [4.6.1. 危害](#461-危害)
        - [4.6.2. 树立软件复用的思想](#462-树立软件复用的思想)
    - [4.7. 代码复杂度问题](#47-代码复杂度问题)
        - [4.7.1. 过长的代码片段](#471-过长的代码片段)
        - [4.7.2. 合理的代码分拆](#472-合理的代码分拆)
        - [4.7.3. 高质量的子程序](#473-高质量的子程序)
            - [4.7.3.1. 子程序的参数](#4731-子程序的参数)
            - [4.7.3.2. 防御式编程](#4732-防御式编程)
    - [4.8. 代码逻辑问题](#48-代码逻辑问题)
    - [4.9. 错误处理](#49-错误处理)
        - [4.9.1. 错误处理决策的两种倾向](#491-错误处理决策的两种倾向)
        - [4.9.2. 软件整体错误处理机制的设计](#492-软件整体错误处理机制的设计)
        - [4.9.3. 断言](#493-断言)
    - [4.10. 异常处理](#410-异常处理)
        - [4.10.1. 传递](#4101-传递)
        - [4.10.2. 异常抛出的规范](#4102-异常抛出的规范)
        - [4.10.3. 异常捕获和处理的规范](#4103-异常捕获和处理的规范)
        - [4.10.4. 安全编程函数](#4104-安全编程函数)
    - [4.11. 代码质量控制](#411-代码质量控制)
        - [4.11.1. 个人测试与调试](#4111-个人测试与调试)
            - [4.11.1.1. 问题定位](#41111-问题定位)
    - [4.12. 代码静态检察](#412-代码静态检察)
        - [4.12.1. 质量门禁](#4121-质量门禁)
    - [4.13. 代码评审](#413-代码评审)
    - [4.14. 代码质量度量](#414-代码质量度量)
        - [4.14.1. 代码复杂度度量](#4141-代码复杂度度量)
    - [4.15. 测试驱动开发（TDD）](#415-测试驱动开发tdd)
        - [4.15.1. 基本过程](#4151-基本过程)
        - [4.15.2. 基本原则](#4152-基本原则)
        - [4.15.3. 单元测试](#4153-单元测试)
            - [4.15.3.1. 框架](#41531-框架)
            - [4.15.3.2. 工具](#41532-工具)
- [5. 软件设计](#5-软件设计)
    - [5.1. 目标](#51-目标)
    - [5.2. 层次](#52-层次)
    - [5.3. 思想](#53-思想)
        - [5.3.1. 分解与抽象](#531-分解与抽象)
            - [5.3.1.1. 软件抽象的选择](#5311-软件抽象的选择)
    - [5.4. 软件体系结构](#54-软件体系结构)
        - [5.4.1. 作用](#541-作用)
    - [5.5. 软件重构](#55-软件重构)
    - [5.6. 软件复用](#56-软件复用)
    - [5.7. 面向对象软件设计](#57-面向对象软件设计)
        - [5.7.1. 过程](#571-过程)
        - [5.7.2. 潜在设计类的来源](#572-潜在设计类的来源)
        - [5.7.3. 判断潜在设计类的合理性](#573-判断潜在设计类的合理性)
        - [5.7.4. 明确设计类职责和协作](#574-明确设计类职责和协作)
        - [5.7.5. 细化设计类内部细节](#575-细化设计类内部细节)
        - [5.7.6. 面向对象设计描述](#576-面向对象设计描述)
        - [5.7.7. 内聚度和耦合度](#577-内聚度和耦合度)
            - [5.7.7.1. 常见内聚形态](#5771-常见内聚形态)
            - [5.7.7.2. 常见耦合形态](#5772-常见耦合形态)
        - [5.7.8. 原则](#578-原则)
    - [5.8. 面向切面编程（AOP）](#58-面向切面编程aop)
        - [5.8.1. 机制](#581-机制)
        - [5.8.2. 相关概念](#582-相关概念)
        - [5.8.3. 实现方法](#583-实现方法)
    - [5.9. 面向对象软件设计中的约定](#59-面向对象软件设计中的约定)
    - [5.10. 契约式设计](#510-契约式设计)
        - [5.10.1. 契约的类型](#5101-契约的类型)
        - [5.10.2. 契约的义务](#5102-契约的义务)
        - [5.10.3. 基本原则](#5103-基本原则)
        - [5.10.4. 运行时检察](#5104-运行时检察)
    - [5.11. 设计模式](#511-设计模式)
        - [5.11.1. OO设计模式分类](#5111-oo设计模式分类)
    - [5.12. 演化式设计](#512-演化式设计)
        - [5.12.1. 抚平变化曲线](#5121-抚平变化曲线)
        - [5.12.2. 平衡计划设计与演化式开发](#5122-平衡计划设计与演化式开发)
        - [5.12.3. 代码坏味道](#5123-代码坏味道)
        - [5.12.4. 软件重构](#5124-软件重构)
- [6. 软件复用](#6-软件复用)
    - [6.1. 软件复用层次](#61-软件复用层次)
        - [6.1.1. 组件级软件复用](#611-组件级软件复用)
        - [6.1.2. 框架级软件复用](#612-框架级软件复用)
        - [6.1.3. 组件、设计模式、框架](#613-组件设计模式框架)
        - [6.1.4. 平台级软件复用](#614-平台级软件复用)
    - [6.2. 软件复用过程](#62-软件复用过程)
        - [6.2.1. 软件产品线](#621-软件产品线)
    - [6.3. 开源代码复用](#63-开源代码复用)
    - [6.4. 三方库管理平台](#64-三方库管理平台)
    - [6.5. 组件级复用](#65-组件级复用)
    - [6.6. 框架级复用](#66-框架级复用)
    - [6.7. 平台级复用](#67-平台级复用)

---

## 1. 概述

### 1.1. 软件的概念

广义“软件”  

计算机软件  

计算机系统中相对硬件的部分

### 1.2. 软件发展历史

#### 1.2.1. 软件产品分类

应用领域

- 通用
- 定制化

部署和运行形态  

- 信息系统  
- 嵌入式系统

### 1.3. 软件开发一般过程

```mermaid
graph LR
    A[现实世界]-->|问题抽象|B[抽象问题描述]
    B-->|问题理解|C[开发人员]
    C-->|编写程序|D[程序]
    D-->|部署运行|E[计算机世界]
```

### 1.4. 如何理解软件工程

软件开发的工程化  

追求：质量、成本、效率

#### 1.4.1. “工程”的基本内涵

过程标准化  

理论和实践支撑

质量有保障

追求实用

### 1.5. 软件工程的根本特性

可靠性  

运行效率  

经济型  

工程  

### 1.6. 基本关注点

质量、成本、时间三角  

以及创新性

### 1.7. 内容层次

“质量”关注点--> 流程--> 方法--> 工具

### 1.8. 根本性困难

软件开发：将问题空间转化为解空间的过工程

根本性困难：

- 不可见的逻辑产品
- 问题空间和解空间的过大差异
- 领域复杂、分布广泛，差异大
- 软件系统的复杂度越来越高

### 1.9. 系统观与演化观

空间维度：系统观

时间维度：演化观

#### 1.9.1. 系统观

软件系统的计算环境以及技术栈

软件系统的物理和社会关系

#### 1.9.2. 演化观

软件系统的持续演化

软件系统的迭代和演化式开发

### 1.10. 软件工程知识体系

SWEBOK  

## 2. 软件过程

### 2.1. 软件过程含义

软件过程：  
定义软件组织和人员在软件产品的定义、开发和维护等阶段中  
所实施的一系列活动和任务  

#### 2.1.1. 三层含义

个体  

整体  

工程  

### 2.2. 软件过程发展历史

### 2.3. 软件过程模型（软件开发模型）

软件过程的结构框架

一定层次上抽象某一类软件过程的共性结构和属性

### 2.4. 经典软件过程模型

- 瀑布模型
- 增量模型
- 演化模型
- 统一过程模型

#### 2.4.1. 瀑布模型

核心思想：过程线性化、顺序化的执行

相对早期软件过程，是一大进步  
但是实际项目很少完全遵循  
切交付太晚，风险大  

#### 2.4.2. 增量模型

开发过程分成若干增量  

每次增量选择部分核心需求作为交付目标，产出可执行中间产品

客户反馈更及时  
相当于以迭代地方式使用瀑布模型

#### 2.4.3. 演化模型

“迭代”以应对不断变化的需求  

典型：螺旋模型  

风险驱动的周期性迭代

原型开发  

- 抛弃式原型
- 增量式原型

#### 2.4.4. 统一过程模型

增量迭代、用例驱动、以体系结构为中心

### 2.5. 软件过程改进

IDEAL软件过程改进模型

计划驱动 vs 敏捷

敏捷：  
充分考虑软件特点，灵活、便于调整

计划：  
传统工程化思维  
稳定、便于协调  

常会有所结合  

### 2.6. 敏捷过程

背景：  
互联网时代

探索：  
共同特点-->拥抱变化  

敏捷宣言

#### 2.6.1. 敏捷过程的特点

需求驱动  

计划都是短期的  

迭代同时强调构造活动  

频繁交付和运行的软件增量  

适应性调整  

**强调适应而非预测**  

12原则

### 2.7. 精益思想

直观理解：  
消除浪费，做有价值的工作  

核心思想：  
在于对系统和开发过程的“持续改善”  
以及“尊重人“  

#### 2.7.1. 改进原则

识别价值  

定义价值流

保持价值流的流动

拉动系统

持续改善

### 2.8. 敏捷思想与精益思想比较

本质同等价值观  

精益思想可以指导敏捷思想

### 2.9. 例子

敏捷实践方法论：

Scrum

XP（极限编程）

看板方法（Kanban）

开发运维一体化（DevOps）

### 2.10. 开发运维一体化

DevOps：  
倡导以移动安全、快速、持续的方式将代码变更部署到生产环境中

#### 2.10.1. 技术价值流与技术实践

技术价值流  

技术实践  

#### 2.10.2. 持续集成（CI）

Continuous Integration

实践：  

开发人员频繁将代码变更提交合并到中央存储库  

自动构建、执行大院测试  

确保可以和原有代码正确集成  

如果失败就要立即进行修复

目标：  

是正在开发的软件始终处于可工作状态  

更快发现、定位和解决问题  

提高软件质量，并减少验证和发布新软件所需时间  

#### 2.10.3. 持续交付

Continuous Delivery

代码变更提交后：

自动构建和执行单元测试  

自动将所有代码编程部署到测试环境和类生产环境  

以确保代码变更可以被正确部署到生产环境  

如果确认无误，可以继续手工部署到生产环境中  

#### 2.10.4. 持续部署

Continuous Deployment

代码变更提交后：

自动构建和执行单元测试  

自动将所有代码编程部署到测试环境和类生产环境  

实现从代码变更提交到生产环境部署的全程自动化而无需人工干预  

## 3. 版本与开发任务管理

软件配置管理：

- 开发任务管理
- 版本管理

### 3.1. 软件配置管理

各种软件制品

变更不可避免，新的版本不断产生

软件开发自身也经常是增量和迭代的

**配置管理：**  
确保软件开发和编程有序进行并向客户发布正确的产品版本的一整套管理方法和工具

#### 3.1.1. 主要内容

版本管理

开发任务管理

构建管理

发布管理

### 3.2. 软件项目的持续规划、开发和发布

持续开展项目的规划、开发与发布

### 3.3. 版本

#### 3.3.1. 版本发布计划

明确版本定位、目标、商业价值等

估算工作量及优先级

分配

创建版本发布计划

#### 3.3.2. 版本管理

任务：  

将各种软件制品都置于系统行的管理之中，进行版本标识  

追踪演化历史  

确保开发人员并行写作开发不会相互影响  

#### 3.3.3. 产品版本号命名

格式：

`M.S.F.B([SP][C])`

- M：主版本号
- S：次版本号
- F：特性版本号
- B：编译版本号
- SP：补丁包版本号
- C：补丁版本号

*\[\]表示可选字段*  

#### 3.3.4. 场景示例

1. 代码演化历史跟踪

2. 历史版本回退

3. 多人开发协作冲突

4. 代码质量检察

### 3.4. 版本控制系统

实现代码版本管理目标的一种有效途径

两种类型：

- 集中式  
- 分布式

#### 3.4.1. 集中式版本控制系统

使用方法：  

开始时，先从服务器拉取工作文件最新版本

完成后，再将更新提交到服务器

因此客户端机器只存储所拉取的文件快照  

代表：  

CVS、SVN

缺点：

联网才能工作  

服务器单点故障会影响整个团队

容易发生版本数据丢失

逐渐被取代

#### 3.4.2. 分布式版本控制系统

使用方法：

每个开发人员维护自己的本地版本库（克隆）  

完成工作后可以将更新提交到本地版本库  

客户端机器存储着完整的版本库

代表：

Mercurial、Git

优点：

无需联网工作

版本数据可以从任何本地库恢复

灵活、强大的分支管理

#### 3.4.3. Git工作流成

1. clone

2. commit

3. pull

4. push

5. checkout

6. add

7. reset

##### 3.4.3.1. Commit

提交  

原子性  

##### 3.4.3.2. 代码分支管理

用于支持多个并行的互不干扰的分支

常用分支类型：

- master: 主分支，用于发布
- develop: 开发分支
- feature: 功能分支
- release: 发布分支，为版本发布做好准备
- hotfix: 补丁分支

分支合并：

发生合并冲突的文件中表基础不同分支中的内容  

开发人员之间对合并冲突进行协商

##### 3.4.3.3. 基线管理

一个分支：一条Codeline（代码线）

一条代码线的上级成为Baseline（基线）

Mainline（主线）：没有基线的代码线

版本管理就是管理这三者的过程

### 3.5. 特性开发任务

#### 3.5.1. 描述

特性：可以给客户带来价值的产品功能

一个特性可以分解为多个用户故事

用户故事：从用户角度对产品功能的详细描述

e.g.

一卡通系统

特性：

- 食堂就餐
- 图书管理
    用户故事：
    - 现场借阅图书
    - 现场归还图书
    - 在线预借图书

#### 3.5.2. 管理流程

开发任务流程管理

交流与沟通

### 3.6. 变更管理

软件开发过程的变更几乎总是无法避免

开发人员不可以随意进行软件变更  
避免引发技术或杨业问题  

需要规范、系统、可控的方式管理软件变更流程

需要 **规范性** 和 **可追踪性**  

#### 3.6.1. 流程

提交变更申请

变更决策

变更的实施与跟踪

变更归档

### 3.7. 缺陷修复过程管理

软件开发和使用过程中经常可以发现缺陷

需要提交缺陷报告（问题单）并进行跟踪

需要实现缺陷修复的有效管理与追踪  
否则容易混乱

#### 3.7.1. 缺陷描述

常用缺陷追踪系统：

JIRA、Bugzilla

#### 3.7.2. 缺陷追踪系统主要功能

缺陷修复流程管理

缺陷交流与沟通

代码管理

#### 3.7.3. 缺陷修复处理流程

### 3.8. 基于追踪与回溯的工作量与质量分析

目的：  
改进软件开发与流程管理过程，以提升软件开发质量

#### 3.8.1. 基于追踪的分析

#### 3.8.2. 基于回溯的分析

#### 3.8.3. 例子

1. SIPOC分析方法
2. 鱼骨图分析方法
3. 5why分析方法

## 4. 高质量编码

### 4.1. 代码质量

外部质量：面向用户以及软件运行和使用

内部质量：面向开发者及持续演化和维护

Clean Code  
逻辑严密，还要可读性强

### 4.2. 代码质量要求

- 可理解性
- 可维护性
- 可靠性
- 信息安全性
- 高效性
- 可移植性

#### 4.2.1. 可理解性、可维护性

代码经常需要阅读并进行维护

编程语言的发展一定程度上的目的就是提高抽象层次，使得程序可读性和可理解性提高

代码的可理解性：又称为代码的可读性  

代码的可维护性：指软件代码易于修改、扩展和复用的程度

可以通过代码逻辑和代码风格来提升：  

- 代码风格：统一命名规范、符合逻辑的排版、适当的注释
- 代码逻辑：降低复杂度、封装复杂性、优化设计结构

#### 4.2.2. 可靠性、信息安全性

可靠性：某种情况下，按设计要求正常运行的概率

针对系统内外部一些异常情况

信息安全性：对恶意威胁的防护能力  

主要关注应对外部的安全威胁  

**首先取决于整体的体系结构设计，同时也与具体代码编写和代码质量有关**  

要求：

本身不容易出错  

不容易被外部影响或破坏

可靠性主要应对内外部异常情况  

安全性主要关注应对外部安全威胁

#### 4.2.3. 高效性

高效性：运行效率高，运行中表现出较高的性能

与编码质量、软件体系结构设计相关

取决于两个方面：

1. 算法的选择
2. 资源使用策略的选择

需要对资源使用的成本效益有着全面的了解  
并慎重做出相关实现决策

要保持对性能问题的敏感  
尤其是涉及常见性能瓶颈的部分（大量磁盘读写、数据库访问、网络传输）  
但也要注意软件工程的权衡取舍  

#### 4.2.4. 可移植性

运行环境也会经常不断变化  

为了适应这种变化，相应的软件代码可能会需要做一些修改  

可移植性：  
代码能多大程度上适应不同运行环境  
需要多少修改代价才能实现迁移  

### 4.3. 代码风格

自解释性  

一致性  

清晰第一，简介为美，风格一致  

#### 4.3.1. 标识符命名

主要以影响对代码的理解

反例：

- 含义不明的标识符命名和魔法数字
- 含义
    - 有意义
    - 字解释
- 形式
    - 驼峰命名法
    - 布尔型变量
- 排版格式  
    - 纵向
    - 横向

java建议：

- 纵向排版

    各部分顺序及空行分隔  

    版权声明、包名、引用包和类、顶层类或接口

    内部声明顺序及空行分隔

    类属性、静态初始化块、实例属性、实例初始化块、构造方法、其他方法  

- 横向排版

    4半角空格缩紧每层  

    每行不超一个语句  

    一行代码不超120字符  

    块注释缩进与上下文相同

### 4.4. 代码注释

注释是开发人员之间的一种交流沟通手段  

目的是为代码提供额外的说明  

- 特别是生层的原理性知识，例如业务规则或设计思考
- 可以对一些容易被忽略的细节进行说明和提醒

并非多多益善

更推荐提高代码的自解释性

#### 4.4.1. 基本原则

语言：团队统一，使用最高效的

对自解释性不好的代码，更需要重构，而不是注释  

注释应该注重为阅读和理解代码提供额外信息  

必要情况下，可以明确文档生成规则，方便通过工具将注释导出为文档，从而保持代码与文档的一致性  

修改代码后，注释也要注意更新

#### 4.4.2. 常见有效类型

1. 补充解释代码意图

2. 给出必要警告或预告

3. 给出代码无法描述的附加信息

### 4.5. 高质量编码对代码逻辑的要求

代码逻辑严密，尽量避免错误

代码逻辑清晰，易于理解和维护

- 控制复杂度
- 减少重复
- 编写高质量自程序

#### 4.5.1. 基本要求

变量声明和初始化

数据类型的选择和使用

代码控制结构

#### 4.5.2. 控制变量作用域

避免作用域过大的变量  

平衡优缺点

确保容易理解，对变量的修改进行控制以保障代码质量很重要

#### 4.5.3. 正面实践

避免一行声明多个变量

进行必要的变量初始化

避免数据溢出

避免使用魔法数字（可以通过常量定义进行替代）

分支语句逻辑要完备，同时避免过于复杂的判断

特殊情况预处理简化嵌套条件判断  

永真的外层循环结合循环体中的退出条件（如果退出条件太复杂可以是这这样实现）

避免空循环体的“死循环”

### 4.6. 重复代码问题

代码复制粘贴是常见的软件复用手段  

不同粒度的复制代码：片段、方法、函数、类或文件、模块和项目

重复代码被认为是代码克隆，一般都被认为是一种需要注意的问题  

#### 4.6.1. 危害

如果一份代码出现太多次：  

理解难度增加

修改难度增加

解决的常见手段：

- 使用代码模版
- 将重复代码提取为公共方法/函数  
- 建立继承层次，将重复代码进行提取  

#### 4.6.2. 树立软件复用的思想

尽量将通用功能实现为可复用的代码单元  

利用各种软件开发框架消除重复代码  

*并非一切重复代码都是可以消除的*  
*重要的还是权衡利弊*  

### 4.7. 代码复杂度问题

人类认知能力有限，难以很好掌握过于复杂的事物和问题  

代码的复杂度与长度以及逻辑组合数量有关，与问题本身复杂度也有关

控制代码复杂度的主要思想：
**分解和抽象**  

#### 4.7.1. 过长的代码片段

控制基本手段：分解  

#### 4.7.2. 合理的代码分拆

前提：体现代码逻辑，符合人的理解习惯  

错误：直接将方法按照顺序拆分，并随意编号  

合理：重逻辑，提取出相对独立的逻辑单元作为单独方法，并赋予合适的名称  

例子：  

减少嵌套条件或循环语句层数的方法：合并条件、按分支逻辑提取函数/方法  

#### 4.7.3. 高质量的子程序

子程序：表示一种功能和逻辑分解  

可以是函数、过程、方法

重要原因：  

降低程序对人的认知复杂度  

方面：  

- 控制自程序复杂度  
    指责单一，功能内聚  
- 参数选择  
    需要准确体现职责并保持简洁  
- 返回值选择

命令与查询分离：  

- 命令：执行操作并返回结果，可能改变状态  
- 查询：仅仅执行所要求的查询，并返回结果，不改变状态  

简短的公共代码也有必要抽取为自程序  
主要是便于理解和统一维护  

##### 4.7.3.1. 子程序的参数

子程序应当没有或者只有很少参数  

参数的排列顺序要保持一致  

不要在子程序中把参数用作工作变量  

对参数的假设或约定应当加以明确（契约式设计）  

返回值：简单、明确  

##### 4.7.3.2. 防御式编程

基本思想  

**你永远不知道别人要做什么**  

数据验证  

可信区域与不可信区域：  

不可信区域：用户、传感器、文件等  
可信区域：内部逻辑  
隔栏：数据验证  

SQL注入的检测与防护  

可信区域上的数据验证：  

保证安全性的同时，避免冗余重复验证带来的性能、资源浪费  

### 4.8. 代码逻辑问题

资源使用：  

注意关闭和释放  

判断条件和返回值检测  

### 4.9. 错误处理

程序运行中可能出现各种错误

适当的错误处理对于提高软件可靠性和可维护性非常重要  

错误识别及处理  
错误处理机制记录错误信息，便于定位  

常见错误处理手段：  

尝试正常服务  
进行错误处理  

要结合具体情况进行选取  

#### 4.9.1. 错误处理决策的两种倾向

正确性：永不返回错误的结果，哪怕不返回  

健壮性：保证软件的正常运行，哪怕偶尔返回一些不够准确的结果

#### 4.9.2. 软件整体错误处理机制的设计

统一策略  
以协调不同层次子程序在错误处理过程中的角色与任务  

对于子程序返回的错误逆袭需要进行检察和处理  

#### 4.9.3. 断言

开发人员对于自己所编写的程序的执行逻辑的掌握，所得出的对于运行到某些特定位置时的状态的判断和假设

运行时对这些假设进行检测，可以及时发现程序运行逻辑与预期不一致的地方，更快定位位置  

断言一般在开发期间使用  

使用场合：  

子程序输入值合法性判断  
子程序输出结果预期检测  
子程序关键点状态检测  
测试代码中对测试结果的预期判断  

检测内容：  

可以在运行时自动检察的条件表达式  
一般包括：  

- 输入、输出、状态值是否在范围内或等于特定值  
- 指针或对象的有效性  
- 相关资源处于合理的状态  
- 变量的值没有被意外修改  
- 多种计算方式的结果相同  

原则：应该只做判断，不应该包含所需执行的代码  

断言会终止程序运行，一般不会在正式版本中使用  

### 4.10. 异常处理

程序运行，异常难免  

难以通过错误处理或断言处理  

因并非可以预期  

许多语言提供异常的处理机制  

#### 4.10.1. 传递

异常会造成子程序的终端  
无法被忽略地被向上层传递  

最终会在某个层次被处理  

一般应用程序中最高层次的用户界面不应该收到没被处理过的异常  

#### 4.10.2. 异常抛出的规范

只在真正例外的情况下才抛出异常，不可以用来推卸责任  

- 增加程序了复杂性
- 弱化了程序的封装性

抛出的异常类型应与所处的抽象层次相符  

异常信息中应当包含理解异常抛出原因所需的全部信息  

#### 4.10.3. 异常捕获和处理的规范

不要直接捕获异常基类  

不要直接捕获可以通过预先检察消除的运行时异常  
*例如空指针、数组越界*  

避免使用空catch语句  

不能处理的异常要继续传递  
可以选择包装后或原样传递  

要防止因为异常信息泄露导致安全问题  

异常处理策略也是一个需要全局考虑的“设计”问题  

#### 4.10.4. 安全编程函数

### 4.11. 代码质量控制

软件构造过程除编码还有：  
本地编译构建、本地个人测试和调制、代码提交和合并、项目集成与测试等  

#### 4.11.1. 个人测试与调试

Testing：开发者测试  

单元测试  

测试驱动开发  

Debug：开发者调试

测试发现问题后对问题的分析和解决的过程  

问题定位  
问题修复  
修复验证  

##### 4.11.1.1. 问题定位

一般调试过程中最难的部分  

比较依赖经验  

常见策略：二分法，不断进行假设验证  

可以利用常见方法和工具提升效率：

断点和单步运行  
难点：难以决定断点位置和需要观察的程序状态  
缺点：侵入式手段，可能改变程序多线程或异常抛出行为  

日志  
记录程序执行过程、中间状态和出错信息，便于还原及分析出错过程  
复杂分布式系统调试的重要手段  
详细程序需要恰到好处  

### 4.12. 代码静态检察

代码通过本地测试，但仍可能存在许多潜在问题  
*逻辑错误、代码坏味道、不好的代码风格*  

相关工具常用于各种代码质量问题的自动化检测  

#### 4.12.1. 质量门禁

个人本地检测  

作为CI流水线的一部份  

作为代码提交或合并前的质量门禁  

### 4.13. 代码评审

### 4.14. 代码质量度量

代码规模度量  

代码复杂度度量  

代码重复度度量  

#### 4.14.1. 代码复杂度度量

代码圈复杂度  

### 4.15. 测试驱动开发（TDD）

先编写测试用例，并以通过测试作为开发任务完成标识  

优势

#### 4.15.1. 基本过程

新功能-->测试用例  

三个阶段：  

"红"：测试失败  
"绿"：测试通过  
"重构"：代码优化（可选）  

#### 4.15.2. 基本原则

测试先行  

用户角度出发  

小步前进  

测试自动化  

小步提交  

及时小规模重构  

#### 4.15.3. 单元测试

单元测试：针对程序基本组成单元的一种测试方法  

##### 4.15.3.1. 框架

应当尽可能自动化  

被测单元经常依赖于其他单元，需要将被测单元与所依赖部分进行隔离，以保证测试结果不受所依赖部分的影响

需要框架

##### 4.15.3.2. 工具

Junit  

CppUnit  

PyUnit

JMockit

## 5. 软件设计

连接软件需求与实现代码  

应对系统复杂性的需要  

应对系统演化性的需要  

### 5.1. 目标

根据对软件解决方案的规划  
回答软件需求如何实现的问题  
为各部分编码实现提出明确要求  

分解和抽象，将待开发的软件分为一系列组成部份  
每次只需专注某一部分，可将其他部份进行抽象了解  

良好的分解和抽象
使得各个组成部份相对独立和松耦合  

### 5.2. 层次

数据设计：全局数据结构设计  

数据实体、属性、之间关系  

体系结构设计：决定系统的高层分解结构以及全局性的设计决策  

组件接口设计  

组件级设计  

### 5.3. 思想

- 分解与抽象
- 软件体系结构
- 关注点分离
- 模块化
- 信息隐藏
- 重构
- 复用

#### 5.3.1. 分解与抽象

人类对复杂性的两个基本应对手段  

软件设计思维的重要基础  

数据抽象和过程抽象  

数据抽象：对于对象的数据化抽象描述  

过程抽象：对于一系列过程性步骤和指令序列的整体抽象  

##### 5.3.1.1. 软件抽象的选择

屏蔽底层细节  
而突出事物本质  

可以极大提高程序的可迁移性和可复用性

### 5.4. 软件体系结构

大规模软件系统（尤其是网络化软件系统）需要更高层的设计考虑

软件体系结构给出了软件系统的顶层设计  

充份体现了分解与抽象的基本原则

总体质量很大程度上取决于体系结构设计

#### 5.4.1. 作用

**分工合作的基础**  

关注点分离

横切关注点的问题  
AOP

模块化  

信息隐藏  

### 5.5. 软件重构

不改变代码外在行为的前提下，对代码做出修改以改进程序的内部结构（设计）

目的：提高软件的可维护性和可扩展性  

### 5.6. 软件复用

层次

方面：  

面向复用的软件开发  
基于复用的软件开发  

### 5.7. 面向对象软件设计

在组件级设计以及组件接口设计中非常重要  

设计内容：  

确定所需要定义的类和接口，以及之间关系  

UML图描述  

模块化设计，应该让类相对独立  

基本原则  

横切关注点以切面（Aspect）方式封装并与相关类结构  

#### 5.7.1. 过程

起点：  

- 规模较大的软件系统  
    给定软件组件设计要求（整体功能、对外接口等）

- 规模较小的软件系统  
    整个系统的软件需求  

基本步骤：  

- 识别设计类  
- 明确设计类职责和协作  
- 细化设计类内部细节  

#### 5.7.2. 潜在设计类的来源

- 问题与  
- 接口  
- 基础设施相关  

#### 5.7.3. 判断潜在设计类的合理性

是否包含多个同类对象所共有的切实当前软件系统所需的属性及操作  

#### 5.7.4. 明确设计类职责和协作

每个设计类的职责实现  

职责与协作很大程度上决定设计质量  

职责单一、相对独立原则  

关注点分离基础，高内聚、低耦合  

考虑通过引入抽象类和接口进行共性沉淀  
降低耦合且更好拓展  

协作关系：  

通过自身能力无法完成的部分职责需要依赖于协作

#### 5.7.5. 细化设计类内部细节

属性主要是：访问修饰符、属性类型、初始值

方法主要是：访问修饰符、参数及类型、返回值类型、前置后置条件

#### 5.7.6. 面向对象设计描述

- [ ] 非常重要！！！必考

设计类的职责和交互关系

**UML** 是个很好的工具  

- UML类图  
- UML顺序图
- UML活动图
- UML状态机图

#### 5.7.7. 内聚度和耦合度

衡量模块独立性  

高内聚模块化设计

低耦合模块化设计

##### 5.7.7.1. 常见内聚形态

- 功能内聚
- 层次内聚
- 通信内聚
- 顺序内聚
- 顺序内聚
- 过程内聚
- 时间内聚
- 功用内聚

从上到下，内聚度由高到低

##### 5.7.7.2. 常见耦合形态

- 内容耦合  
    避免出现
- 共用耦合  
    严格限制
- 控制耦合  
    尽量利用多态机制消除
- 印记耦合  
    尽量将方法参数缩小为接口、抽象类或简单数据项
- 数据耦合  
    尽量减少参数数量  
- 过程调用  
    将重复出现的调用序列封装为高层过程  
- 类型使用  
    尽量将所使用的类型缩小为接口、抽象类  
- 文件包含和包引入  
    消除不必要的包含和引入  
- 外部依赖  
    尽量减少代码中的外部依赖  

#### 5.7.8. 原则

一个主要目标：可维护性、可拓展性  

SOLID设计原则：  

- 单一职责原则  
    内聚性
- 开闭原则  
    对拓展开放、对修改封闭
- 里氏替换原则  
    子类可以替代父类
- 迪米特法则  
    限制一个类与其他类的依赖关系  
- 接口隔离原则  
    多个特化接口优于一个通用接口
- 依赖倒置原则  
    强调尽量依赖于抽象而非具体  

### 5.8. 面向切面编程（AOP）

面向对象软件设计以包、类、方法实现层次化模块分解  
以及相应的数据和操作封装  
以关注点分类作为基本的设计思想  

单一维度的模块化机制的问题：  

- 代码交织  
- 代码散布  

AOP支持横切关注点解耦和模块化封装  

#### 5.8.1. 机制

基本程序上定义连接点  
然后工具自动将切面编织到对应连接点上  
最终形成完整程序  

横切关注点单独以切面方式封装  

#### 5.8.2. 相关概念

切面：实现关注点的模块化封装  

通知：由切面封装、将被插入到基本程序中制定地方执行的功能代码

连接点：基本程序结构或执行流上的一种可以明确定义的位置  

切点指示器  

编织  

#### 5.8.3. 实现方法

具体语言或框架实现  

Spring AOP  

### 5.9. 面向对象软件设计中的约定

约定  

基于接口定义的设计约定  

问题  
主要是模糊性造成的  

### 5.10. 契约式设计

Design by Contract  

将接口的实现放和调用方之间的关系比喻成商业活动中的供应方与需求方的关系  

#### 5.10.1. 契约的类型

契约应当明确定义并且可以进行验证  

常见形式：  

对程序运行状态的断言  

前置条件  

后置条件  

不变式  

#### 5.10.2. 契约的义务

前置条件，调用方确保  

后置条件方法实现方确保  

不变式，该软件元素的所有方法的实现方都应确保  

#### 5.10.3. 基本原则

方法定义原则：  

区分命令与查询  

区分基本查询和派生查询  

契约定义原则：  

针对每个派生查询定义一个使用基本查询表示的后置条件  

每个命令定义一个后置条件规定每个基本查询的值  

为每个查询和命令定义合适的前置条件

通过不定式定义对象的恒定特性

#### 5.10.4. 运行时检察

有语言支持  

也可以通过语言拓展来支持  

### 5.11. 设计模式

“模式”一般用于表示某种可借鉴的参考解决方案  

软件应用中存在很多共性设计问题  

有所差异，但可以抽象为共性问题  

#### 5.11.1. OO设计模式分类

创建型模式  

结构型模式  

行为型模式  

### 5.12. 演化式设计

计划驱动的开发过程  

代表：瀑布模型

迭代和演化式开发过程  

代表：敏捷开发  

#### 5.12.1. 抚平变化曲线

#### 5.12.2. 平衡计划设计与演化式开发  

#### 5.12.3. 代码坏味道

及时重构  

典型类别：  

- 重复代码  
- 过长函数  
- 过长类  
- 过长参数列表
- 发散式变化
- 霰弹式变化
- 依恋情结
- 数据泥团

#### 5.12.4. 软件重构

外部行为不变，改进内部设计  

发现重构机会  

“技术债务”

常见软件重构操作：  

- 重新组织方法
- 对象间移动特性
- 重新组织数据  
- 简化条件表达式
- 简化方法调用
- 处理继承关系
- 大型重构

IDE自动化重构操作

## 6. 软件复用

已成为一种重要的软件开发手段  

带来的变化：  

推动了通用软件资产的沉淀  
极大促进了软件行业的分工  

占软件开发中的比重：  

越来越重要  

### 6.1. 软件复用层次

需求、相关设计方案、实现代码

体系结构设计、组件级设计  

推荐：  

经过良好封装以及清晰的API定义的软件组件  

#### 6.1.1. 组件级软件复用

主要目的：实现特定功能和特性  

形式：软件组件（构件）

可复用范围：  

- 一方库
- 二方库
- 三方库

#### 6.1.2. 框架级软件复用

主要目的：获得支撑应用运行的整体性框架  

形式：各种软件开发框架  

共性实现上支持定制和拓展  

#### 6.1.3. 组件、设计模式、框架

组件：调用

设计模式：实例化

框架：拓展

#### 6.1.4. 平台级软件复用

主要目的：不仅获得特别功能和特性的实现以及整体框架支持，还有包括获得软件应用的部署和运行支持  

形式：小程序等  

典型代表：各种互联网应用开放平台  

### 6.2. 软件复用过程

生产者复用-->可复用软件制品-->消费者复用  

#### 6.2.1. 软件产品线

工程框架：领域工程（核心部分），领域核心资产的生产阶段  

体现生产者复用

### 6.3. 开源代码复用

开源社区  

开源!=完全自由使用源码  

一般有相应的许可证协议进行约束  

常用开源软件许可证协议：  

- BSD类
- MPL类
- GPL类
    - GPL
    - LGPL
    - AGPL
    - SSPL

### 6.4. 三方库管理平台

例如Maven

### 6.5. 组件级复用

软件开发库复用  

在线服务复用  

RESTful API  
资源为核心  
通过HTTP动词来操作资源  
一般使用HTTP协议作为进程间通信机制，使用XML或JSON格式来表示资源信息  

安全性与幂等性  

接口描述规范  

最广泛的描述规范和框架：Swagger

Swagger关键属性：  

- bashPath
- bashPath
- 动词
- produces
- parameters
- responses

### 6.6. 框架级复用

例如MVC模式  

### 6.7. 平台级复用

例如小程序  
